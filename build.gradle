plugins {
    id 'java'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id("com.palantir.graal") version("0.12.0")

    // Apply GraalVM Native Image plugin
    id 'org.graalvm.buildtools.native' version '0.9.22'

    id "io.qameta.allure" version "2.11.2"

    id 'ru.iopump.qa.allure' version "0.1.2"
}

// Shadowing Test Sources and Dependencies
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

group = 'org.example'
version = '1.0-SNAPSHOT'

ext {
    allureVersion = '2.22.2'
}

repositories {
    mavenCentral()
}

reporting {
    baseDir = "$buildDir/reports"
}

allureServer {
    relativeResultDir = 'build/allure-results'
    allureServerUrl = 'http://localhost:8083'
}

allure {
//    io.qameta.allure:allure-junit5:2.22.2
    version = allureVersion
    report {
        // There might be several tasks producing the report, so the property
        // configures a base directory for all the reports
        // Each task creates its own subfolder there
        reportDir.set(project.reporting.baseDirectory.dir("allure-report"))

    }

}

sourceSets {

}

graal {

    javaVersion('11')
    mainClass('ru.heisenbug.cmd.Tester')
    outputName('guitester')
    option('-cp')
    option('build/output/libs/*')
//    option('/home/mike/tools/libs/picocli-4.7.1.jar')

    option('--verbose')
    option('--no-fallback')
    option('-H:+ReportExceptionStackTraces')
//    option('--allow-incomplete-classpath')
}


// ./gradlew -q dependencies --configuration testImplementation
dependencies {

    testImplementation 'org.junit.platform:junit-platform-launcher:1.9.2'

    testImplementation platform('org.junit:junit-bom:5.9.1')
    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'
    testImplementation 'org.selenide:selenide-selenoid:2.3.7'

    // https://mvnrepository.com/artifact/io.qameta.allure/allure-selenide
    testImplementation 'io.qameta.allure:allure-selenide:2.22.2'
    testImplementation 'io.qameta.allure:allure-junit5:2.22.2'

    annotationProcessor('info.picocli:picocli-codegen:4.7.1')
    testImplementation 'info.picocli:picocli:4.7.1'

    testImplementation('org.apache.logging.log4j:log4j-api:2.20.0')
    testImplementation('org.apache.logging.log4j:log4j-core:2.20.0')
    testImplementation('org.apache.logging.log4j:log4j-slf4j2-impl:2.20.0')

    // nativeImageTestCompileOnly fileTree(dir: "${project.buildDir}/output/libs", include: '*.jar')

}


configurations {

    testImplementation {
        canBeResolved = true
        // canBeConsumed = true
    }

    // nativeImageClasspath.extendsFrom(testImplementation)
}

tasks.register('pwdShow', Exec) {
    commandLine "pwd"
}

task allureTest(type: Exec) {
    commandLine "./build/allure/commandline/bin/allure"
}

task generateAllureReport(type: Exec) {
    workingDir "${buildDir}"
//    commandLine "allure/commandline/bin/allure generate -c allure-results -o reports/allure-report"
    executable = "allure/commandline/bin/allure"
    args = ["generate", "-c", "allure-results", "-o", "reports/allure-report"]

}
// test.finalizedBy(generateAllureReport)

task openAllureReport(type: Exec) {
    workingDir "${buildDir}"
//    commandLine "allure/commandline/bin/allure open reports/allure-report"
    executable = "allure/commandline/bin/allure"
    args = ["open", "reports/allure-report"]
}

// Open Allure Report in the browser
task serveAllureReport(type: Exec) {
    workingDir "${buildDir}"
    if(org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        executable = "${buildDir}/allure/commandline/bin/allure"
    } else {
        executable = "${buildDir}/allure/commandline/bin/allure.bat"
    }
    args = ["serve", "allure-results"]
}

graalvmNative {
    toolchainDetection = false

    binaries {
        main {
            // Main options
            imageName = 'guitester' // The name of the native image, defaults to the project name
            mainClass = 'ru.heisenbug.cmd.Tester' // The main class to use, defaults to the application.mainClass
            debug = true // Determines if debug info should be generated, defaults to false (alternatively add --debug-native to the CLI)
            verbose = true // Add verbose output, defaults to false
            fallback = true // Sets the fallback mode of native-image, defaults to false
            sharedLibrary = false // Determines if image is a shared library, defaults to false if `java-library` plugin isn't included
            quickBuild = false // Determines if image is being built in quick build mode (alternatively use GRAALVM_QUICK_BUILD environment variable, or add --native-quick-build to the CLI)
            richOutput = false // Determines if native-image building should be done with rich output
            requiredVersion = '22.3' // The minimal GraalVM version, can be `MAJOR`, `MAJOR.MINOR` or `MAJOR.MINOR.PATCH`

            // systemProperties = [name1: 'value1', name2: 'value2'] // Sets the system properties to use for the native image builder
            // configurationFileDirectories.from(file('src/my-config')) // Adds a native image configuration file directory, containing files like reflection configuration
            // excludeConfig.put("org.example.test:artifact:version", ["^/META-INF/native-image/.*", "^/config/.*"]) // Excludes configuration that matches one of given regexes from JAR of dependency with said coordinates.
            // excludeConfig.put(file("path/to/artifact.jar"), listOf("^/META-INF/native-image/.*", "^/config/.*"))

            // Advanced options
            // buildArgs.add("-cp ${project.buildDir}/output/libs/*")
            // buildArgs.add('-H:Extra') // Passes '-H:Extra' to the native image builder options. This can be used to pass parameters which are not directly supported by this extension
            // jvmArgs.add('flag') // Passes 'flag' directly to the JVM running the native image builder

            // Runtime options
            runtimeArgs.add('--help') // Passes '--help' to built image, during "nativeRun" task

            // classpath("${project.buildDir}/output/libs/*")
            // classpath = sourceSets.test.runtimeClasspath

            useFatJar = true // Instead of passing each jar individually, builds a fat jar
        }
    }
}

tasks.named('nativeCompile') {
    outputs.upToDateWhen { false }
}

println("${project.buildDir}/libs/guitester-${version}.jar")

//tasks.named("nativeCompile") {
//    classpathJar = ("${project.buildDir}/libs/guitester-${version}.jar")
//}


test {
    testLogging {
        showStandardStreams = true
        events = ["passed", "failed", "skipped"]
    }
    useJUnitPlatform()
    testLogging {
        showStandardStreams = true
        events = ["passed", "failed", "skipped"]
    }
}

shadowJar {
    archiveBaseName.set('guitester')
    archiveClassifier.set('')
//    archiveVersion.set('')

    mergeServiceFiles()

    from sourceSets.test.output
    configurations = [project.configurations.testImplementation]

}

// ./gradlew clean createGuitesterJar
// java -jar ./build/libs/guitester-1.0-SNAPSHOT.jar smoketest --browser=firefox
tasks.register('createGuitesterJar') {
    dependsOn(shadowJar)
}

//Gradle 8+ toolchain error "Toolchain from `executable` property does not match toolchain from `javaLauncher` property" when different JDK and running main class in subproject
gradle.taskGraph.whenReady { taskGraph ->
    def task = taskGraph.allTasks.find { it.name.endsWith(".main()") }
    if (task instanceof JavaExec) {
        task.executable = task.javaLauncher.get().executablePath.asFile.absolutePath
        println('task.executable: ' + task.executable)
    }
}

task testShadowJar(type: ShadowJar) {
    manifest {
        attributes (
                'Main-Class': 'ru.heisenbug.cmd.Tester',
                'Description': 'This is an application JAR for guitests'
        )
    }
    archiveBaseName.set('guitester')
    // archiveClassifier.set("tests")
    archiveClassifier.set("")

    mergeServiceFiles()

    from sourceSets.test.output
    configurations = [project.configurations.testImplementation]
}

// ./gradlew clean build
// without test runs
// ./gradlew clean jar
// java -cp './build/output/libs/*:./build/libs/tests-cmd-1.0-SNAPSHOT.jar' ru.heisenbug.cmd.Tester

// java -jar ./build/libs/guitester-1.0-SNAPSHOT.jar smoketest --browser=firefox
// create guitester executable image
// ./gradlew nativeImage --info
build{
    dependsOn testShadowJar
}

tasks.register('libJar', Jar) {
    from sourceSets.test.output
}

jar {
    dependsOn testClasses, testShadowJar
    manifest {
        attributes(
                'Main-Class': 'ru.heisenbug.cmd.Tester',
                'Description': 'This is an application JAR for guitests',
        )

    }
    from sourceSets.test.output
}

//task createManifest(type: Jar) {
//    manifest {
//        attributes("Class-Path": configurations.testImplementation.collect { it.getName() }.join(' '))
//    }
//    from { configurations.testImplementation.collect { it.isDirectory() ? it : zipTree(it) } }
//}


task testJar(type: Jar, dependsOn: testClasses) {
    manifest {
        attributes( 'Main-Class': 'ru.heisenbug.cmd.Tester' )
    }
    from sourceSets.test.output
}

// ./gradlew clean customFatJar --info
// java -jar ./build/libs/testerFat-1.0-SNAPSHOT.jar smoketest --browser=firefox

task customFatJar(type: Jar, dependsOn: testClasses) {
//    from sourceSets.test.output
//     archiveClassifier = 'test'
    manifest {
        attributes( 'Main-Class': 'ru.heisenbug.cmd.Tester' )
    }
    archiveBaseName = 'testerFat'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from sourceSets.test.output
    from {
        configurations.testCompileClasspath.collect { it.isDirectory() ? it : zipTree(it) }
        configurations.testRuntimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }

}

task printSourceSetInformation(){
    doLast{
        sourceSets.each { srcSet ->
            println "["+srcSet.name+"]"
            print "-->Source directories: "+srcSet.allJava.srcDirs+"\n"
            print "-->Output directories: "+srcSet.output.classesDirs.files+"\n"
            println ""
        }
        println "testImplementation: " + project.configurations.testImplementation
    }
}

// copy all dependencies jar files
task copyToLib(type: Copy) {
    into "${buildDir}/output/libs"
    from configurations.testImplementation
}

nativeImage.dependsOn(copyToLib)

tasks.register("myConfigs") {
    doFirst{
        sourceSets.test.runtimeClasspath.each { println it}
        println '#############################################################'
        println configurations.testCompileClasspath.collect {it.isDirectory() ? it: zipTree(it)}.join('\n')
        println '#############################################################'
    }
    doLast {
        configurations.forEach { println(it) }
    }
}

// java -jar ./build/libs/testerFat-1.0-SNAPSHOT.jar smoketest --browser=firefox

